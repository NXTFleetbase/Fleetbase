{"version":3,"file":"intersection-observer-admin.umd.js","sources":["../src/registry.ts","../src/notification.ts","../src/index.ts"],"sourcesContent":["// fix by importing IOptions\nexport interface IOptions {\n  [key: string]: any;\n}\n\nexport default class Registry {\n  public registry: WeakMap<HTMLElement | Window, IOptions>;\n\n  constructor() {\n    this.registry = new WeakMap();\n  }\n\n  public elementExists(elem: HTMLElement | Window): boolean | null {\n    return this.registry.has(elem);\n  }\n\n  public getElement(elem: HTMLElement | Window): any {\n    return this.registry.get(elem);\n  }\n\n  /**\n   * administrator for lookup in the future\n   *\n   * @method add\n   * @param {HTMLElement | Window} element - the item to add to root element registry\n   * @param {IOption} options\n   * @param {IOption.root} [root] - contains optional root e.g. window, container div, etc\n   * @param {IOption.watcher} [observer] - optional\n   * @public\n   */\n  public addElement(element: HTMLElement | Window, options?: IOptions): void {\n    if (!element) {\n      return;\n    }\n\n    this.registry.set(element, options || {});\n  }\n\n  /**\n   * @method remove\n   * @param {HTMLElement|Window} target\n   * @public\n   */\n  public removeElement(target: HTMLElement | Window): void {\n    this.registry.delete(target);\n  }\n\n  /**\n   * reset weak map\n   *\n   * @method destroy\n   * @public\n   */\n  public destroyRegistry(): void {\n    this.registry = new WeakMap();\n  }\n}\n","import Registry from './registry';\n\nconst noop = () => {};\n\nexport enum CallbackType {\n  enter = 'enter',\n  exit = 'exit'\n}\n\nexport default abstract class Notifications {\n  private registry: Registry;\n\n  constructor() {\n    this.registry = new Registry();\n  }\n\n  /**\n   * Adds an EventListener as a callback for an event key.\n   * @param type 'enter' or 'exit'\n   * @param key The key of the event\n   * @param callback The callback function to invoke when the event occurs\n   */\n  public addCallback(\n    type: CallbackType,\n    element: HTMLElement | Window,\n    callback: (data?: any) => void\n  ): void {\n    let entry;\n    if (type === CallbackType.enter) {\n      entry = { [CallbackType.enter]: callback };\n    } else {\n      entry = { [CallbackType.exit]: callback };\n    }\n\n    this.registry.addElement(\n      element,\n      Object.assign({}, this.registry.getElement(element), entry)\n    );\n  }\n\n  /**\n   * @hidden\n   * Executes registered callbacks for key.\n   * @param type\n   * @param element\n   * @param data\n   */\n  public dispatchCallback(\n    type: CallbackType,\n    element: HTMLElement | Window,\n    data?: any\n  ): void {\n    if (type === CallbackType.enter) {\n      const { enter = noop } = this.registry.getElement(element);\n      enter(data);\n    } else {\n      // no element in WeakMap possible because element may be removed from DOM by the time we get here\n      const found = this.registry.getElement(element);\n      if (found && found.exit) {\n        found.exit(data);\n      }\n    }\n  }\n}\n","import Notifications, { CallbackType } from './notification';\nimport Registry from './registry';\n\nexport interface IOptions {\n  root?: HTMLElement;\n  rootMargin?: string;\n  threshold?: number | number[];\n  [key: string]: any;\n}\n\ntype StateForRoot = {\n  elements: [HTMLElement];\n  options: IOptions;\n  intersectionObserver: any;\n};\n\ntype PotentialRootEntry = {\n  [stringifiedOptions: string]: StateForRoot;\n};\n\nexport default class IntersectionObserverAdmin extends Notifications {\n  private elementRegistry: Registry;\n\n  constructor() {\n    super();\n    this.elementRegistry = new Registry();\n  }\n\n  /**\n   * Adds element to observe via IntersectionObserver and stores element + relevant callbacks and observer options in static\n   * administrator for lookup in the future\n   *\n   * @method observe\n   * @param {HTMLElement | Window} element\n   * @param {Object} options\n   * @public\n   */\n  public observe(element: HTMLElement, options: IOptions = {}): void {\n    if (!element) {\n      return;\n    }\n\n    this.elementRegistry.addElement(element, { ...options });\n\n    this.setupObserver(element, { ...options });\n  }\n\n  /**\n   * Unobserve target element and remove element from static admin\n   *\n   * @method unobserve\n   * @param {HTMLElement|Window} target\n   * @param {Object} options\n   * @public\n   */\n  public unobserve(target: HTMLElement, options: IOptions): void {\n    const matchingRootEntry:\n      | StateForRoot\n      | undefined = this.findMatchingRootEntry(options);\n\n    if (matchingRootEntry) {\n      const { intersectionObserver } = matchingRootEntry;\n      intersectionObserver.unobserve(target);\n    }\n  }\n\n  /**\n   * register event to handle when intersection observer detects enter\n   *\n   * @method addEnterCallback\n   * @public\n   */\n  public addEnterCallback(\n    element: HTMLElement | Window,\n    callback: (data?: any) => void\n  ) {\n    this.addCallback(CallbackType.enter, element, callback);\n  }\n\n  /**\n   * register event to handle when intersection observer detects exit\n   *\n   * @method addExitCallback\n   * @public\n   */\n  public addExitCallback(\n    element: HTMLElement | Window,\n    callback: (data?: any) => void\n  ) {\n    this.addCallback(CallbackType.exit, element, callback);\n  }\n\n  /**\n   * retrieve registered callback and call with data\n   *\n   * @method dispatchEnterCallback\n   * @public\n   */\n  public dispatchEnterCallback(element: HTMLElement | Window, entry: any) {\n    this.dispatchCallback(CallbackType.enter, element, entry);\n  }\n\n  /**\n   * retrieve registered callback and call with data on exit\n   *\n   * @method dispatchExitCallback\n   * @public\n   */\n  public dispatchExitCallback(element: HTMLElement | Window, entry: any) {\n    this.dispatchCallback(CallbackType.exit, element, entry);\n  }\n\n  /**\n   * cleanup data structures and unobserve elements\n   *\n   * @method destroy\n   * @public\n   */\n  public destroy(): void {\n    this.elementRegistry.destroyRegistry();\n  }\n\n  /**\n   * use function composition to curry options\n   *\n   * @method setupOnIntersection\n   * @param {Object} options\n   */\n  protected setupOnIntersection(options: IOptions): Function {\n    return (ioEntries: any) => {\n      return this.onIntersection(options, ioEntries);\n    };\n  }\n\n  protected setupObserver(element: HTMLElement, options: IOptions): void {\n    const { root = window } = options;\n\n    // First - find shared root element (window or target HTMLElement)\n    // this root is responsible for coordinating it's set of elements\n    const potentialRootMatch:\n      | PotentialRootEntry\n      | null\n      | undefined = this.findRootFromRegistry(root);\n\n    // Second - if there is a matching root, see if an existing entry with the same options\n    // regardless of sort order. This is a bit of work\n    let matchingEntryForRoot;\n    if (potentialRootMatch) {\n      matchingEntryForRoot = this.determineMatchingElements(\n        options,\n        potentialRootMatch\n      );\n    }\n\n    // next add found entry to elements and call observer if applicable\n    if (matchingEntryForRoot) {\n      const { elements, intersectionObserver } = matchingEntryForRoot;\n      elements.push(element);\n      if (intersectionObserver) {\n        intersectionObserver.observe(element);\n      }\n    } else {\n      // otherwise start observing this element if applicable\n      // watcher is an instance that has an observe method\n      const intersectionObserver = this.newObserver(element, options);\n\n      const observerEntry: StateForRoot = {\n        elements: [element],\n        intersectionObserver,\n        options\n      };\n\n      // and add entry to WeakMap under a root element\n      // with watcher so we can use it later on\n      const stringifiedOptions: string = this.stringifyOptions(options);\n      if (potentialRootMatch) {\n        // if share same root and need to add new entry to root match\n        // not functional but :shrug\n        potentialRootMatch[stringifiedOptions] = observerEntry;\n      } else {\n        // no root exists, so add to WeakMap\n        this.elementRegistry.addElement(root, {\n          [stringifiedOptions]: observerEntry\n        });\n      }\n    }\n  }\n\n  private newObserver(\n    element: HTMLElement,\n    options: IOptions\n  ): IntersectionObserver {\n    // No matching entry for root in static admin, thus create new IntersectionObserver instance\n    const { root, rootMargin, threshold } = options;\n\n    const newIO = new IntersectionObserver(\n      this.setupOnIntersection(options).bind(this),\n      { root, rootMargin, threshold }\n    );\n    newIO.observe(element);\n\n    return newIO;\n  }\n\n  /**\n   * IntersectionObserver callback when element is intersecting viewport\n   * either when `isIntersecting` changes or `intersectionRadio` crosses on of the\n   * configured `threshold`s.\n   * Exit callback occurs eagerly (when element is initially out of scope)\n   * See https://stackoverflow.com/questions/53214116/intersectionobserver-callback-firing-immediately-on-page-load/53385264#53385264\n   *\n   * @method onIntersection\n   * @param {Object} options\n   * @param {Array} ioEntries\n   * @private\n   */\n  private onIntersection(options: IOptions, ioEntries: Array<any>): void {\n    ioEntries.forEach(entry => {\n      const { isIntersecting, intersectionRatio } = entry;\n      let threshold = options.threshold || 0;\n      if (Array.isArray(threshold)) {\n        threshold = threshold[threshold.length - 1];\n      }\n\n      // then find entry's callback in static administration\n      const matchingRootEntry:\n        | StateForRoot\n        | undefined = this.findMatchingRootEntry(options);\n\n      // first determine if entry intersecting\n      if (isIntersecting || intersectionRatio > threshold) {\n        if (matchingRootEntry) {\n          matchingRootEntry.elements.some((element: HTMLElement) => {\n            if (element && element === entry.target) {\n              this.dispatchEnterCallback(element, entry);\n              return true;\n            }\n            return false;\n          });\n        }\n      } else {\n        if (matchingRootEntry) {\n          matchingRootEntry.elements.some((element: HTMLElement) => {\n            if (element && element === entry.target) {\n              this.dispatchExitCallback(element, entry);\n              return true;\n            }\n            return false;\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * { root: { stringifiedOptions: { observer, elements: []...] } }\n   * @method findRootFromRegistry\n   * @param {HTMLElement|Window} root\n   * @private\n   * @return {Object} of elements that share same root\n   */\n  private findRootFromRegistry(\n    root: HTMLElement | Window\n  ): PotentialRootEntry | null | undefined {\n    if (this.elementRegistry) {\n      return this.elementRegistry.getElement(root);\n    }\n  }\n\n  /**\n   * We don't care about options key order because we already added\n   * to the static administrator\n   *\n   * @method findMatchingRootEntry\n   * @param {Object} options\n   * @return {Object} entry with elements and other options\n   */\n  private findMatchingRootEntry(options: IOptions): StateForRoot | undefined {\n    const { root = window } = options;\n    const matchingRoot:\n      | PotentialRootEntry\n      | null\n      | undefined = this.findRootFromRegistry(root);\n\n    if (matchingRoot) {\n      const stringifiedOptions: string = this.stringifyOptions(options);\n      return matchingRoot[stringifiedOptions];\n    }\n  }\n\n  /**\n   * Determine if existing elements for a given root based on passed in options\n   * regardless of sort order of keys\n   *\n   * @method determineMatchingElements\n   * @param {Object} options\n   * @param {Object} potentialRootMatch e.g. { stringifiedOptions: { elements: [], ... }, stringifiedOptions: { elements: [], ... }}\n   * @private\n   * @return {Object} containing array of elements and other meta\n   */\n  private determineMatchingElements(\n    options: IOptions,\n    potentialRootMatch: PotentialRootEntry\n  ): StateForRoot | undefined {\n    const matchingStringifiedOptions = Object.keys(potentialRootMatch).filter(\n      key => {\n        const { options: comparableOptions } = potentialRootMatch[key];\n        return this.areOptionsSame(options, comparableOptions);\n      }\n    )[0];\n\n    return potentialRootMatch[matchingStringifiedOptions];\n  }\n\n  /**\n   * recursive method to test primitive string, number, null, etc and complex\n   * object equality.\n   *\n   * @method areOptionsSame\n   * @param {any} a\n   * @param {any} b\n   * @private\n   * @return {boolean}\n   */\n  private areOptionsSame(a: IOptions | any, b: IOptions | any): boolean {\n    if (a === b) {\n      return true;\n    }\n\n    // simple comparison\n    const type1 = Object.prototype.toString.call(a);\n    const type2 = Object.prototype.toString.call(b);\n    if (type1 !== type2) {\n      return false;\n    } else if (type1 !== '[object Object]' && type2 !== '[object Object]') {\n      return a === b;\n    }\n\n    if (a && b && typeof a === 'object' && typeof b === 'object') {\n      // complex comparison for only type of [object Object]\n      for (const key in a) {\n        if (Object.prototype.hasOwnProperty.call(a, key)) {\n          // recursion to check nested\n          if (this.areOptionsSame(a[key], b[key]) === false) {\n            return false;\n          }\n        }\n      }\n    }\n\n    // if nothing failed\n    return true;\n  }\n\n  /**\n   * Stringify options for use as a key.\n   * Excludes options.root so that the resulting key is stable\n   *\n   * @param {Object} options\n   * @private\n   * @return {String}\n   */\n  private stringifyOptions(options: IOptions): string {\n    const { root } = options;\n\n    const replacer = (key: string, value: string): string => {\n      if (key === 'root' && root) {\n        const classList = Array.prototype.slice.call(root.classList);\n\n        const classToken = classList.reduce((acc, item) => {\n          return (acc += item);\n        }, '');\n\n        const id: string = root.id;\n\n        return `${id}-${classToken}`;\n      }\n\n      return value;\n    };\n\n    return JSON.stringify(options, replacer);\n  }\n}\n"],"names":[],"mappings":"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"}