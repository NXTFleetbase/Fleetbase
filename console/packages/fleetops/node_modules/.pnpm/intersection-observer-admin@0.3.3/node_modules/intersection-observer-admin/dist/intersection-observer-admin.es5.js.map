{"version":3,"file":"intersection-observer-admin.es5.js","sources":["../src/registry.ts","../src/notification.ts","../src/index.ts"],"sourcesContent":["// fix by importing IOptions\nexport interface IOptions {\n  [key: string]: any;\n}\n\nexport default class Registry {\n  public registry: WeakMap<HTMLElement | Window, IOptions>;\n\n  constructor() {\n    this.registry = new WeakMap();\n  }\n\n  public elementExists(elem: HTMLElement | Window): boolean | null {\n    return this.registry.has(elem);\n  }\n\n  public getElement(elem: HTMLElement | Window): any {\n    return this.registry.get(elem);\n  }\n\n  /**\n   * administrator for lookup in the future\n   *\n   * @method add\n   * @param {HTMLElement | Window} element - the item to add to root element registry\n   * @param {IOption} options\n   * @param {IOption.root} [root] - contains optional root e.g. window, container div, etc\n   * @param {IOption.watcher} [observer] - optional\n   * @public\n   */\n  public addElement(element: HTMLElement | Window, options?: IOptions): void {\n    if (!element) {\n      return;\n    }\n\n    this.registry.set(element, options || {});\n  }\n\n  /**\n   * @method remove\n   * @param {HTMLElement|Window} target\n   * @public\n   */\n  public removeElement(target: HTMLElement | Window): void {\n    this.registry.delete(target);\n  }\n\n  /**\n   * reset weak map\n   *\n   * @method destroy\n   * @public\n   */\n  public destroyRegistry(): void {\n    this.registry = new WeakMap();\n  }\n}\n","import Registry from './registry';\n\nconst noop = () => {};\n\nexport enum CallbackType {\n  enter = 'enter',\n  exit = 'exit'\n}\n\nexport default abstract class Notifications {\n  private registry: Registry;\n\n  constructor() {\n    this.registry = new Registry();\n  }\n\n  /**\n   * Adds an EventListener as a callback for an event key.\n   * @param type 'enter' or 'exit'\n   * @param key The key of the event\n   * @param callback The callback function to invoke when the event occurs\n   */\n  public addCallback(\n    type: CallbackType,\n    element: HTMLElement | Window,\n    callback: (data?: any) => void\n  ): void {\n    let entry;\n    if (type === CallbackType.enter) {\n      entry = { [CallbackType.enter]: callback };\n    } else {\n      entry = { [CallbackType.exit]: callback };\n    }\n\n    this.registry.addElement(\n      element,\n      Object.assign({}, this.registry.getElement(element), entry)\n    );\n  }\n\n  /**\n   * @hidden\n   * Executes registered callbacks for key.\n   * @param type\n   * @param element\n   * @param data\n   */\n  public dispatchCallback(\n    type: CallbackType,\n    element: HTMLElement | Window,\n    data?: any\n  ): void {\n    if (type === CallbackType.enter) {\n      const { enter = noop } = this.registry.getElement(element);\n      enter(data);\n    } else {\n      // no element in WeakMap possible because element may be removed from DOM by the time we get here\n      const found = this.registry.getElement(element);\n      if (found && found.exit) {\n        found.exit(data);\n      }\n    }\n  }\n}\n","import Notifications, { CallbackType } from './notification';\nimport Registry from './registry';\n\nexport interface IOptions {\n  root?: HTMLElement;\n  rootMargin?: string;\n  threshold?: number | number[];\n  [key: string]: any;\n}\n\ntype StateForRoot = {\n  elements: [HTMLElement];\n  options: IOptions;\n  intersectionObserver: any;\n};\n\ntype PotentialRootEntry = {\n  [stringifiedOptions: string]: StateForRoot;\n};\n\nexport default class IntersectionObserverAdmin extends Notifications {\n  private elementRegistry: Registry;\n\n  constructor() {\n    super();\n    this.elementRegistry = new Registry();\n  }\n\n  /**\n   * Adds element to observe via IntersectionObserver and stores element + relevant callbacks and observer options in static\n   * administrator for lookup in the future\n   *\n   * @method observe\n   * @param {HTMLElement | Window} element\n   * @param {Object} options\n   * @public\n   */\n  public observe(element: HTMLElement, options: IOptions = {}): void {\n    if (!element) {\n      return;\n    }\n\n    this.elementRegistry.addElement(element, { ...options });\n\n    this.setupObserver(element, { ...options });\n  }\n\n  /**\n   * Unobserve target element and remove element from static admin\n   *\n   * @method unobserve\n   * @param {HTMLElement|Window} target\n   * @param {Object} options\n   * @public\n   */\n  public unobserve(target: HTMLElement, options: IOptions): void {\n    const matchingRootEntry:\n      | StateForRoot\n      | undefined = this.findMatchingRootEntry(options);\n\n    if (matchingRootEntry) {\n      const { intersectionObserver } = matchingRootEntry;\n      intersectionObserver.unobserve(target);\n    }\n  }\n\n  /**\n   * register event to handle when intersection observer detects enter\n   *\n   * @method addEnterCallback\n   * @public\n   */\n  public addEnterCallback(\n    element: HTMLElement | Window,\n    callback: (data?: any) => void\n  ) {\n    this.addCallback(CallbackType.enter, element, callback);\n  }\n\n  /**\n   * register event to handle when intersection observer detects exit\n   *\n   * @method addExitCallback\n   * @public\n   */\n  public addExitCallback(\n    element: HTMLElement | Window,\n    callback: (data?: any) => void\n  ) {\n    this.addCallback(CallbackType.exit, element, callback);\n  }\n\n  /**\n   * retrieve registered callback and call with data\n   *\n   * @method dispatchEnterCallback\n   * @public\n   */\n  public dispatchEnterCallback(element: HTMLElement | Window, entry: any) {\n    this.dispatchCallback(CallbackType.enter, element, entry);\n  }\n\n  /**\n   * retrieve registered callback and call with data on exit\n   *\n   * @method dispatchExitCallback\n   * @public\n   */\n  public dispatchExitCallback(element: HTMLElement | Window, entry: any) {\n    this.dispatchCallback(CallbackType.exit, element, entry);\n  }\n\n  /**\n   * cleanup data structures and unobserve elements\n   *\n   * @method destroy\n   * @public\n   */\n  public destroy(): void {\n    this.elementRegistry.destroyRegistry();\n  }\n\n  /**\n   * use function composition to curry options\n   *\n   * @method setupOnIntersection\n   * @param {Object} options\n   */\n  protected setupOnIntersection(options: IOptions): Function {\n    return (ioEntries: any) => {\n      return this.onIntersection(options, ioEntries);\n    };\n  }\n\n  protected setupObserver(element: HTMLElement, options: IOptions): void {\n    const { root = window } = options;\n\n    // First - find shared root element (window or target HTMLElement)\n    // this root is responsible for coordinating it's set of elements\n    const potentialRootMatch:\n      | PotentialRootEntry\n      | null\n      | undefined = this.findRootFromRegistry(root);\n\n    // Second - if there is a matching root, see if an existing entry with the same options\n    // regardless of sort order. This is a bit of work\n    let matchingEntryForRoot;\n    if (potentialRootMatch) {\n      matchingEntryForRoot = this.determineMatchingElements(\n        options,\n        potentialRootMatch\n      );\n    }\n\n    // next add found entry to elements and call observer if applicable\n    if (matchingEntryForRoot) {\n      const { elements, intersectionObserver } = matchingEntryForRoot;\n      elements.push(element);\n      if (intersectionObserver) {\n        intersectionObserver.observe(element);\n      }\n    } else {\n      // otherwise start observing this element if applicable\n      // watcher is an instance that has an observe method\n      const intersectionObserver = this.newObserver(element, options);\n\n      const observerEntry: StateForRoot = {\n        elements: [element],\n        intersectionObserver,\n        options\n      };\n\n      // and add entry to WeakMap under a root element\n      // with watcher so we can use it later on\n      const stringifiedOptions: string = this.stringifyOptions(options);\n      if (potentialRootMatch) {\n        // if share same root and need to add new entry to root match\n        // not functional but :shrug\n        potentialRootMatch[stringifiedOptions] = observerEntry;\n      } else {\n        // no root exists, so add to WeakMap\n        this.elementRegistry.addElement(root, {\n          [stringifiedOptions]: observerEntry\n        });\n      }\n    }\n  }\n\n  private newObserver(\n    element: HTMLElement,\n    options: IOptions\n  ): IntersectionObserver {\n    // No matching entry for root in static admin, thus create new IntersectionObserver instance\n    const { root, rootMargin, threshold } = options;\n\n    const newIO = new IntersectionObserver(\n      this.setupOnIntersection(options).bind(this),\n      { root, rootMargin, threshold }\n    );\n    newIO.observe(element);\n\n    return newIO;\n  }\n\n  /**\n   * IntersectionObserver callback when element is intersecting viewport\n   * either when `isIntersecting` changes or `intersectionRadio` crosses on of the\n   * configured `threshold`s.\n   * Exit callback occurs eagerly (when element is initially out of scope)\n   * See https://stackoverflow.com/questions/53214116/intersectionobserver-callback-firing-immediately-on-page-load/53385264#53385264\n   *\n   * @method onIntersection\n   * @param {Object} options\n   * @param {Array} ioEntries\n   * @private\n   */\n  private onIntersection(options: IOptions, ioEntries: Array<any>): void {\n    ioEntries.forEach(entry => {\n      const { isIntersecting, intersectionRatio } = entry;\n      let threshold = options.threshold || 0;\n      if (Array.isArray(threshold)) {\n        threshold = threshold[threshold.length - 1];\n      }\n\n      // then find entry's callback in static administration\n      const matchingRootEntry:\n        | StateForRoot\n        | undefined = this.findMatchingRootEntry(options);\n\n      // first determine if entry intersecting\n      if (isIntersecting || intersectionRatio > threshold) {\n        if (matchingRootEntry) {\n          matchingRootEntry.elements.some((element: HTMLElement) => {\n            if (element && element === entry.target) {\n              this.dispatchEnterCallback(element, entry);\n              return true;\n            }\n            return false;\n          });\n        }\n      } else {\n        if (matchingRootEntry) {\n          matchingRootEntry.elements.some((element: HTMLElement) => {\n            if (element && element === entry.target) {\n              this.dispatchExitCallback(element, entry);\n              return true;\n            }\n            return false;\n          });\n        }\n      }\n    });\n  }\n\n  /**\n   * { root: { stringifiedOptions: { observer, elements: []...] } }\n   * @method findRootFromRegistry\n   * @param {HTMLElement|Window} root\n   * @private\n   * @return {Object} of elements that share same root\n   */\n  private findRootFromRegistry(\n    root: HTMLElement | Window\n  ): PotentialRootEntry | null | undefined {\n    if (this.elementRegistry) {\n      return this.elementRegistry.getElement(root);\n    }\n  }\n\n  /**\n   * We don't care about options key order because we already added\n   * to the static administrator\n   *\n   * @method findMatchingRootEntry\n   * @param {Object} options\n   * @return {Object} entry with elements and other options\n   */\n  private findMatchingRootEntry(options: IOptions): StateForRoot | undefined {\n    const { root = window } = options;\n    const matchingRoot:\n      | PotentialRootEntry\n      | null\n      | undefined = this.findRootFromRegistry(root);\n\n    if (matchingRoot) {\n      const stringifiedOptions: string = this.stringifyOptions(options);\n      return matchingRoot[stringifiedOptions];\n    }\n  }\n\n  /**\n   * Determine if existing elements for a given root based on passed in options\n   * regardless of sort order of keys\n   *\n   * @method determineMatchingElements\n   * @param {Object} options\n   * @param {Object} potentialRootMatch e.g. { stringifiedOptions: { elements: [], ... }, stringifiedOptions: { elements: [], ... }}\n   * @private\n   * @return {Object} containing array of elements and other meta\n   */\n  private determineMatchingElements(\n    options: IOptions,\n    potentialRootMatch: PotentialRootEntry\n  ): StateForRoot | undefined {\n    const matchingStringifiedOptions = Object.keys(potentialRootMatch).filter(\n      key => {\n        const { options: comparableOptions } = potentialRootMatch[key];\n        return this.areOptionsSame(options, comparableOptions);\n      }\n    )[0];\n\n    return potentialRootMatch[matchingStringifiedOptions];\n  }\n\n  /**\n   * recursive method to test primitive string, number, null, etc and complex\n   * object equality.\n   *\n   * @method areOptionsSame\n   * @param {any} a\n   * @param {any} b\n   * @private\n   * @return {boolean}\n   */\n  private areOptionsSame(a: IOptions | any, b: IOptions | any): boolean {\n    if (a === b) {\n      return true;\n    }\n\n    // simple comparison\n    const type1 = Object.prototype.toString.call(a);\n    const type2 = Object.prototype.toString.call(b);\n    if (type1 !== type2) {\n      return false;\n    } else if (type1 !== '[object Object]' && type2 !== '[object Object]') {\n      return a === b;\n    }\n\n    if (a && b && typeof a === 'object' && typeof b === 'object') {\n      // complex comparison for only type of [object Object]\n      for (const key in a) {\n        if (Object.prototype.hasOwnProperty.call(a, key)) {\n          // recursion to check nested\n          if (this.areOptionsSame(a[key], b[key]) === false) {\n            return false;\n          }\n        }\n      }\n    }\n\n    // if nothing failed\n    return true;\n  }\n\n  /**\n   * Stringify options for use as a key.\n   * Excludes options.root so that the resulting key is stable\n   *\n   * @param {Object} options\n   * @private\n   * @return {String}\n   */\n  private stringifyOptions(options: IOptions): string {\n    const { root } = options;\n\n    const replacer = (key: string, value: string): string => {\n      if (key === 'root' && root) {\n        const classList = Array.prototype.slice.call(root.classList);\n\n        const classToken = classList.reduce((acc, item) => {\n          return (acc += item);\n        }, '');\n\n        const id: string = root.id;\n\n        return `${id}-${classToken}`;\n      }\n\n      return value;\n    };\n\n    return JSON.stringify(options, replacer);\n  }\n}\n"],"names":[],"mappings":"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"}