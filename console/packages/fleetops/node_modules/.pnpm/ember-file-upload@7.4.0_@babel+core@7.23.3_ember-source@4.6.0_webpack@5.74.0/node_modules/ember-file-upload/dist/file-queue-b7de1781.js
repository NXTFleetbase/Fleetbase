import { H as HTTPRequest, _ as _defineProperty, U as UploadFileReader } from './upload-file-reader-a231da11.js';
import { assert } from '@ember/debug';
import Service from '@ember/service';
import { registerDestructor } from '@ember/destroyable';
import { action } from '@ember/object';
import { modifier } from 'ember-modifier';
import { TrackedSet, TrackedMap } from 'tracked-built-ins';
import { tracked } from '@glimmer/tracking';
import RSVP from 'rsvp';
import { waitForPromise } from '@ember/test-waiters';
import { guidFor } from '@ember/object/internals';

function _initializerDefineProperty(target, property, descriptor, context) {
  if (!descriptor) return;
  Object.defineProperty(target, property, {
    enumerable: descriptor.enumerable,
    configurable: descriptor.configurable,
    writable: descriptor.writable,
    value: descriptor.initializer ? descriptor.initializer.call(context) : void 0
  });
}

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {
  var desc = {};
  Object.keys(descriptor).forEach(function (key) {
    desc[key] = descriptor[key];
  });
  desc.enumerable = !!desc.enumerable;
  desc.configurable = !!desc.configurable;
  if ('value' in desc || desc.initializer) {
    desc.writable = true;
  }
  desc = decorators.slice().reverse().reduce(function (desc, decorator) {
    return decorator(target, property, desc) || desc;
  }, desc);
  if (context && desc.initializer !== void 0) {
    desc.value = desc.initializer ? desc.initializer.call(context) : void 0;
    desc.initializer = undefined;
  }
  if (desc.initializer === void 0) {
    Object.defineProperty(target, property, desc);
    desc = null;
  }
  return desc;
}

function _classApplyDescriptorGet(receiver, descriptor) {
  if (descriptor.get) {
    return descriptor.get.call(receiver);
  }
  return descriptor.value;
}

function _classExtractFieldDescriptor(receiver, privateMap, action) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to " + action + " private field on non-instance");
  }
  return privateMap.get(receiver);
}

function _classPrivateFieldGet(receiver, privateMap) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "get");
  return _classApplyDescriptorGet(receiver, descriptor);
}

function _classApplyDescriptorSet(receiver, descriptor, value) {
  if (descriptor.set) {
    descriptor.set.call(receiver, value);
  } else {
    if (!descriptor.writable) {
      throw new TypeError("attempted to set read only private field");
    }
    descriptor.value = value;
  }
}

function _classPrivateFieldSet(receiver, privateMap, value) {
  var descriptor = _classExtractFieldDescriptor(receiver, privateMap, "set");
  _classApplyDescriptorSet(receiver, descriptor, value);
  return value;
}

/**
 * Possible file states.
 *
 * @remarks
 *
 * Here is the statechart describing the flow of state:
 *
 * ```
 *       .------.     .---------.     .--------.
 *   o--| queued |-->| uploading |-->| uploaded |
 *       `------`     `---------`     `--------`
 *          ^              |    .-------.
 *          |              |`->| aborted |
 *          |              |    `-------`
 *          |  .------.    |    .---------.
 *          `-| failed |<-` `->| timed_out |-.
 *          |  `------`         `---------`  |
 *          `-------------------------------`
 * ```
 */
let FileState = /*#__PURE__*/function (FileState) {
  FileState["Queued"] = "queued";
  FileState["Uploading"] = "uploading";
  FileState["TimedOut"] = "timed_out";
  FileState["Aborted"] = "aborted";
  FileState["Uploaded"] = "uploaded";
  FileState["Failed"] = "failed";
  return FileState;
}({});
let FileSource = /*#__PURE__*/function (FileSource) {
  FileSource["Browse"] = "browse";
  FileSource["DragAndDrop"] = "drag-and-drop";
  FileSource["Web"] = "web";
  FileSource["DataUrl"] = "data-url";
  FileSource["Blob"] = "blob";
  return FileSource;
}({});

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function clone(object) {
  return object ? _objectSpread({}, object) : {};
}
function normalizeOptions(file, url, options) {
  if (typeof url === 'object') {
    options = url;
    url = undefined;
  }
  options = clone(options);
  options.url = options.url || url;
  options.method = options.method || 'POST';
  options.accepts = options.accepts || ['application/json', 'text/javascript'];
  if (!Object.prototype.hasOwnProperty.call(options, 'contentType')) {
    options.contentType = file.type;
  }
  options.headers = clone(options.headers);
  options.data = clone(options.data);
  options.fileKey = options.fileKey || 'file';
  if (options.headers.Accept == null) {
    if (!Array.isArray(options.accepts)) {
      options.accepts = [options.accepts];
    }
    options.headers.Accept = options.accepts.join(',');
  }

  // Set Content-Type in the data payload
  // instead of the headers, since the header
  // for Content-Type will always be multipart/form-data
  if (options.contentType) {
    options.data['Content-Type'] = options.contentType;
  }
  options.data[options.fileKey] = file.file;
  options.withCredentials = options.withCredentials || false;
  return options;
}
function upload(file, url, opts, uploadFn) {
  if (['queued', 'failed', 'timed_out', 'aborted'].indexOf(file.state) === -1) {
    assert(`The file ${file.id} is in the state "${file.state}" and cannot be requeued.`);
  }
  const options = normalizeOptions(file, url, opts);
  const request = new HTTPRequest({
    withCredentials: options.withCredentials,
    label: `${options.method} ${file.name} to ${options.url}`
  });
  request.open(options.method ?? 'POST', options.url ?? '', true, '', '');

  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
  // @ts-ignore
  Object.keys(options.headers).forEach(function (key) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    request.setRequestHeader(key, options.headers[key]);
  });
  if (options.timeout) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    request.timeout = options.timeout;
  }
  request.onprogress = function (evt) {
    if (!evt) return;
    if (!evt.lengthComputable || evt.total === 0) return;
    file.loaded = evt.loaded;
    file.size = evt.total;
    file.progress = evt.loaded / evt.total * 100;
  };
  request.ontimeout = () => {
    file.state = FileState.TimedOut;
    file.queue?.flush();
  };
  request.onabort = () => {
    file.state = FileState.Aborted;
    file.queue?.flush();
  };
  file.state = FileState.Uploading;
  return waitForPromise(uploadFn(request, options).then(function (response) {
    file.state = FileState.Uploaded;
    file.queue?.uploadSucceeded(file, response);
    return response;
  }).catch(function (response) {
    file.state = FileState.Failed;
    file.queue?.uploadFailed(file, response);
    return RSVP.reject(response);
  }).finally(() => file.queue?.flush()));
}

var _class$1, _descriptor, _descriptor2, _descriptor3, _source, _id, _name$1, _size;
function _classPrivateFieldInitSpec$2(obj, privateMap, value) { _checkPrivateRedeclaration$2(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration$2(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

/**
 * Files provide a uniform interface for interacting
 * with data that can be uploaded or read.
 */
let UploadFile = (_class$1 = (_source = /*#__PURE__*/new WeakMap(), _id = /*#__PURE__*/new WeakMap(), _name$1 = /*#__PURE__*/new WeakMap(), _size = /*#__PURE__*/new WeakMap(), class UploadFile {
  constructor(file, source) {
    _defineProperty(this, "file", void 0);
    _classPrivateFieldInitSpec$2(this, _source, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "queue", void 0);
    _classPrivateFieldInitSpec$2(this, _id, {
      writable: true,
      value: `file-${guidFor(this)}`
    });
    _classPrivateFieldInitSpec$2(this, _name$1, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldInitSpec$2(this, _size, {
      writable: true,
      value: 0
    });
    /** The number of bytes that have been uploaded to the server */
    _initializerDefineProperty(this, "loaded", _descriptor, this);
    /**
     * The current progress of the upload, as a percentage in the
     * range of 0 to 100.
     */
    _initializerDefineProperty(this, "progress", _descriptor2, this);
    /**
     * The current state that the file is in.
     */
    _initializerDefineProperty(this, "state", _descriptor3, this);
    this.file = file;
    _classPrivateFieldSet(this, _source, source);
  }

  /**
   * The source of the file. This is useful
   * for applications that want to gather
   * analytics about how users upload their
   * content.
   */
  get source() {
    return _classPrivateFieldGet(this, _source);
  }
  /** A unique id generated for this file. */
  get id() {
    return _classPrivateFieldGet(this, _id);
  }
  /** The file name */
  get name() {
    return _classPrivateFieldGet(this, _name$1) ?? this.file?.name;
  }
  set name(value) {
    _classPrivateFieldSet(this, _name$1, value);
  }
  /** The size of the file in bytes. */
  get size() {
    return _classPrivateFieldGet(this, _size) || this.file.size;
  }
  set size(value) {
    _classPrivateFieldSet(this, _size, value);
  }

  /**
   * The MIME type of the file.
   *
   * For a image file this may be `image/png`.
   */
  get type() {
    return this.file.type;
  }

  /**
   * Returns the appropriate file extension of
   * the file according to the type
   */
  get extension() {
    return this.type.split('/').slice(-1)[0];
  }
  // /**
  //   The source of the file. This is useful
  //   for applications that want to gather
  //   analytics about how users upload their
  //   content.

  //   This property can be one of the following:

  //   - `browse`
  //   - `drag-and-drop`
  //   - `web`
  //   - `data-url`
  //   - `blob`

  //   `browse` is the source when the file is created
  //   using the native file picker.

  //   `drag-and-drop` is the source when the file was
  //   created using drag and drop from their desktop.

  //   `web` is the source when the file was created
  //   by dragging the file from another webpage.

  //   `data-url` is the source when the file is created
  //   from a data URL using the `fromDataURL` method for
  //   files. This usually means that the file was created
  //   manually by the developer on behalf of the user.

  //   `blob` is the source when the file is created
  //   from a blob using the `fromBlob` method for
  //   files. This usually means that the file was created
  //   manually by the developer.

  //   @accessor source
  //   @type {String}
  //   @default ''
  //   @readonly
  //  */
  // source?: FileSource;
  /**
   * Upload file with `application/octet-stream` content type.
   *
   * @param url Your server endpoint where to upload the file
   * @param options additional request options
   */
  uploadBinary(url, options) {
    options.contentType = 'application/octet-stream';
    return upload(this, url, options, request => {
      this.queue?.uploadStarted(this);
      return request.send(this.file);
    });
  }

  /**
   * Upload file to your server
   *
   * @param url Your server endpoint where to upload the file
   * @param options additional options, eg. `{ fileKey: string, data: { key: string } }`
   */
  upload(url, options) {
    return upload(this, url, options, (request, opts) => {
      // Build the form
      const form = new FormData();
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      for (const key of Object.keys(opts.data)) {
        if (key === opts.fileKey) {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          form.append(key, opts.data[key], this.name);
        } else {
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          form.append(key, opts.data[key]);
        }
      }
      this.queue?.uploadStarted(this);
      return request.send(form);
    });
  }

  /**
   * Resolves with Blob as ArrayBuffer
   */
  readAsArrayBuffer() {
    const reader = new UploadFileReader({
      label: `Read ${this.name} as an ArrayBuffer`
    });
    return reader.readAsArrayBuffer(this.file);
  }

  /**
   * Resolves with Blob as DataURL
   */
  readAsDataURL() {
    const reader = new UploadFileReader({
      label: `Read ${this.name} as a Data URI`
    });
    return reader.readAsDataURL(this.file);
  }

  /**
   * Resolves with Blob as binary string
   */
  readAsBinaryString() {
    const reader = new UploadFileReader({
      label: `Read ${this.name} as a binary string`
    });
    return reader.readAsBinaryString(this.file);
  }

  /**
   * Resolves with Blob as plain text
   */
  readAsText() {
    const reader = new UploadFileReader({
      label: `Read ${this.name} as text`
    });
    return reader.readAsText(this.file);
  }

  /**
   * Creates a file object that can be read or uploaded to a
   * server from a Blob object.
   *
   * @param blob the blob to create the file from.
   * @param source the source that created the blob.
   * @returns the file
   */
  static fromBlob(blob, source = FileSource.Blob) {
    const file = new File([blob], 'blob', {
      type: blob.type
    });
    return new this(file, source);
  }

  /**
   * Creates a file object that can be read or uploaded to a
   * server from a data URL.
   *
   * @param dataURL the data URL to create the file from.
   * @param source the source of the data URL.
   * @returns the file
   */
  static fromDataURL(dataURL, source = FileSource.DataUrl) {
    const [typeInfo, base64String] = dataURL.split(',');
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    const mimeType = typeInfo.match(/:(.*?);/)[1];
    const binaryString = atob(base64String);
    const binaryData = new Uint8Array(binaryString.length);
    for (let i = 0, len = binaryString.length; i < len; i++) {
      binaryData[i] = binaryString.charCodeAt(i);
    }
    const blob = new Blob([binaryData], {
      type: mimeType
    });
    return this.fromBlob(blob, source);
  }
}), (_descriptor = _applyDecoratedDescriptor(_class$1.prototype, "loaded", [tracked], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return 0;
  }
}), _descriptor2 = _applyDecoratedDescriptor(_class$1.prototype, "progress", [tracked], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return 0;
  }
}), _descriptor3 = _applyDecoratedDescriptor(_class$1.prototype, "state", [tracked], {
  configurable: true,
  enumerable: true,
  writable: true,
  initializer: function () {
    return FileState.Queued;
  }
})), _class$1);

var _class, _listeners, _name, _distinctFiles;
function _classPrivateFieldInitSpec$1(obj, privateMap, value) { _checkPrivateRedeclaration$1(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration$1(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }

/**
 * The Queue is a collection of files that
 * are being manipulated by the user.
 *
 * Queues are designed to persist the state
 * of uploads when a user navigates around your
 * application.
 */
let Queue = (_class = (_listeners = /*#__PURE__*/new WeakMap(), _name = /*#__PURE__*/new WeakMap(), _distinctFiles = /*#__PURE__*/new WeakMap(), class Queue {
  /**
   * The unique identifier of the queue.
   *
   * @remarks
   * Queue names should be deterministic so they
   * can be retrieved. It's recommended to provide
   * a helpful name.
   *
   * If the queue belongs to a top level collection,
   * photos, the good name for this queue may be `"photos"`.
   *
   * If you're uploading images to an artwork, the
   * best name would incoporate both `"artworks"` and
   * the identifier of the artwork. A good name for this
   * queue may be `"artworks/{{id}}/photos"`, where `{{id}}`
   * is a dynamic segment that is generated from the artwork id.
   */
  get name() {
    return _classPrivateFieldGet(this, _name);
  }

  /** The FileQueue service. */

  /**
   * The list of files in the queue. This automatically gets
   * flushed when all the files in the queue have settled.
   *
   * @remarks
   * Note that files that have failed need to be manually
   * removed from the queue. This is so they can be retried
   * without resetting the state of the queue, orphaning the
   * file from its queue. Upload failures can happen due to a
   * timeout or a server response. If you choose to use the
   * `abort` method, the file will fail to upload, but will
   * be removed from the requeuing proccess, and will be
   * considered to be in a settled state.
   *
   * @defaultValue []
   */
  get files() {
    return [..._classPrivateFieldGet(this, _distinctFiles).values()];
  }

  /**
   * The total size of all files currently being uploaded in bytes.
   *
   * @defaultValue 0
   */
  get size() {
    return this.files.reduce((acc, {
      size
    }) => {
      return acc + size;
    }, 0);
  }

  /**
   * The number of bytes that have been uploaded to the server.
   *
   * @defaultValue 0
   */
  get loaded() {
    return this.files.reduce((acc, {
      loaded
    }) => {
      return acc + loaded;
    }, 0);
  }

  /**
   * The current progress of all uploads, as a percentage in the
   * range of 0 to 100.
   *
   * @defaultValue 0
   */
  get progress() {
    const percent = this.loaded / this.size || 0;
    return Math.floor(percent * 100);
  }
  constructor({
    name,
    fileQueue
  }) {
    _classPrivateFieldInitSpec$1(this, _listeners, {
      writable: true,
      value: new Set()
    });
    _classPrivateFieldInitSpec$1(this, _name, {
      writable: true,
      value: void 0
    });
    _defineProperty(this, "fileQueue", void 0);
    _classPrivateFieldInitSpec$1(this, _distinctFiles, {
      writable: true,
      value: new TrackedSet()
    });
    _defineProperty(this, "selectFile", modifier((element, _positional, {
      filter,
      onFilesSelected
    }) => {
      const changeHandler = event => {
        const {
          files: fileList
        } = event.target;
        if (!fileList) {
          return;
        }
        const files = Array.from(fileList);
        const selectedFiles = [];
        for (const file of files) {
          if (filter && !filter?.(file, files, files.indexOf(file))) {
            continue;
          }
          let uploadFile;
          if (file instanceof File) {
            uploadFile = new UploadFile(file, FileSource.Browse);
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          else if (file instanceof Blob) {
            uploadFile = UploadFile.fromBlob(file, FileSource.Browse);
          }
          if (uploadFile) {
            selectedFiles.push(uploadFile);
            this.add(uploadFile);
          }
        }
        onFilesSelected?.(selectedFiles);

        // this will reset the input, so the _same_ file can be picked again
        // Without, the `change` event wouldn't be fired, as it is still the same
        // value
        element.value = '';
      };
      element.addEventListener('change', changeHandler);
      return () => {
        element.removeEventListener('change', changeHandler);
      };
    },
    // @ts-expect-error ember-modifier@^3 requires an options hash as second argument
    // used to opt-in to lazy argument handling, which is the default for ember-modifier@^4
    {
      eager: false
    }));
    _classPrivateFieldSet(this, _name, name);
    this.fileQueue = fileQueue;
  }
  addListener(listener) {
    _classPrivateFieldGet(this, _listeners).add(listener);
  }
  removeListener(listener) {
    _classPrivateFieldGet(this, _listeners).delete(listener);
  }

  /**
   * Add a file to the queue
   * @param file the file to be added
   */
  add(file) {
    if (_classPrivateFieldGet(this, _distinctFiles).has(file)) {
      return;
    }
    file.queue = this;
    _classPrivateFieldGet(this, _distinctFiles).add(file);
    for (const listener of _classPrivateFieldGet(this, _listeners)) {
      listener.onFileAdded?.(file);
    }
  }

  /**
   * Remove a file from the queue
   * @param file the file to be removed
   */
  remove(file) {
    if (!_classPrivateFieldGet(this, _distinctFiles).has(file)) {
      return;
    }
    file.queue = undefined;
    _classPrivateFieldGet(this, _distinctFiles).delete(file);
    for (const listener of _classPrivateFieldGet(this, _listeners)) {
      listener.onFileRemoved?.(file);
    }
  }
  uploadStarted(file) {
    for (const listener of _classPrivateFieldGet(this, _listeners)) {
      listener.onUploadStarted?.(file);
    }
  }
  uploadSucceeded(file, response) {
    for (const listener of _classPrivateFieldGet(this, _listeners)) {
      listener.onUploadSucceeded?.(file, response);
    }
  }
  uploadFailed(file, response) {
    for (const listener of _classPrivateFieldGet(this, _listeners)) {
      listener.onUploadFailed?.(file, response);
    }
  }

  /**
   * Flushes the `files` property if they have settled. This
   * will only flush files when all files have arrived at a terminus
   * of their state chart (`uploaded` and `aborted`).
   *
   * Files *may* be requeued by the user in the `failed` or `timed_out`
   * states.
   */
  flush() {
    if (this.files.length === 0) {
      return;
    }
    const allFilesHaveSettled = this.files.every(file => {
      return [FileState.Uploaded, FileState.Aborted].includes(file.state);
    });
    if (allFilesHaveSettled) {
      this.files.forEach(file => file.queue = undefined);
      _classPrivateFieldGet(this, _distinctFiles).clear();
    }
  }
}), (_applyDecoratedDescriptor(_class.prototype, "add", [action], Object.getOwnPropertyDescriptor(_class.prototype, "add"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "remove", [action], Object.getOwnPropertyDescriptor(_class.prototype, "remove"), _class.prototype)), _class);

function _classPrivateFieldInitSpec(obj, privateMap, value) { _checkPrivateRedeclaration(obj, privateMap); privateMap.set(obj, value); }
function _checkPrivateRedeclaration(obj, privateCollection) { if (privateCollection.has(obj)) { throw new TypeError("Cannot initialize the same private elements twice on an object"); } }
const DEFAULT_QUEUE = Symbol('DEFAULT_QUEUE');

/**
 * The file queue service is a global file
 * queue that manages all files being uploaded.
 *
 * This service can be used to query the current
 * upload state when a user leaves the app,
 * asking them whether they want to cancel
 * the remaining uploads.
 */
var _queues = /*#__PURE__*/new WeakMap();
class FileQueueService extends Service {
  constructor(...args) {
    super(...args);
    _defineProperty(this, "queues", new TrackedMap());
    /**
     * Identical untracked map to avoid mutating tracked state during rendering
     * when checking for existing queues.
     */
    _classPrivateFieldInitSpec(this, _queues, {
      writable: true,
      value: new Map()
    });
  }
  /**
   * Returns a queue with the given name
   *
   * @param name The name of the queue to find
   * @returns The queue if it exists
   */
  find(name) {
    return _classPrivateFieldGet(this, _queues).get(name);
  }

  /**
   * Create a new queue with the given name.
   *
   * @param name The name of the queue to create
   * @returns The new queue.
   */
  create(name) {
    assert(`Queue names are required to be unique. "${String(name)}" has already been reserved.`, !_classPrivateFieldGet(this, _queues).has(name));
    const queue = new Queue({
      name,
      fileQueue: this
    });
    registerDestructor(queue, () => {
      _classPrivateFieldGet(this, _queues).delete(name);
      this.queues.delete(name);
    });
    _classPrivateFieldGet(this, _queues).set(name, queue);
    this.queues.set(name, queue);
    return queue;
  }
  findOrCreate(name) {
    return this.find(name) ?? this.create(name);
  }

  /**
   * The list of all files in queues. This automatically gets
   * flushed when all the files in the queue have settled.
   *
   * @remarks
   * Note that files that have failed need to be manually
   * removed from the queue. This is so they can be retried
   * without resetting the state of the queue, orphaning the
   * file from its queue. Upload failures can happen due to a
   * timeout or a server response. If you choose to use the
   * `abort` method, the file will fail to upload, but will
   * be removed from the requeuing proccess, and will be
   * considered to be in a settled state.
   *
   * @defaultValue []
   */
  get files() {
    return [...this.queues.values()].reduce((acc, queue) => {
      return [...acc, ...queue.files];
    }, []);
  }

  /**
   * The total size of all files currently being uploaded in bytes.
   *
   * @defaultValue 0
   */
  get size() {
    return this.files.reduce((acc, {
      size
    }) => {
      return acc + size;
    }, 0);
  }

  /**
   * The number of bytes that have been uploaded to the server.
   *
   * @defaultValue 0
   */
  get loaded() {
    return this.files.reduce((acc, {
      loaded
    }) => {
      return acc + loaded;
    }, 0);
  }

  /**
   * The current progress of all uploads, as a percentage in the
   * range of 0 to 100.
   *
   * @defaultValue 0
   */
  get progress() {
    const percent = this.loaded / this.size || 0;
    return Math.floor(percent * 100);
  }
}

export { DEFAULT_QUEUE as D, FileSource as F, Queue as Q, UploadFile as U, _applyDecoratedDescriptor as _, _initializerDefineProperty as a, FileQueueService as b, FileState as c };
//# sourceMappingURL=file-queue-b7de1781.js.map
