import { bind } from '@ember/runloop';
import RSVP from 'rsvp';

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}

function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

function parseHeaders(headerString) {
  return headerString.split(/\n|\r/).filter(str => str !== '').reduce((headers, headerString) => {
    const parts = headerString.split(/^([0-9A-Za-z_-]*:)/);
    if (parts.length > 0 && parts[1] && parts[2]) {
      headers.append(parts[1].slice(0, -1), parts[2].trim());
    }
    return headers;
  }, new Headers());
}
function parseResponse(request) {
  const body = request.response === '' ? null : request.response;
  if (request.status >= 200 && request.status < 600) {
    return new Response(body, {
      status: request.status,
      statusText: request.statusText,
      headers: parseHeaders(request.getAllResponseHeaders())
    });
  } else {
    return Response.error();
  }
}
class HTTPRequest {
  constructor(options = {}) {
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    _defineProperty(this, "onprogress", void 0);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    _defineProperty(this, "ontimeout", void 0);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    _defineProperty(this, "onabort", void 0);
    _defineProperty(this, "request", void 0);
    _defineProperty(this, "resolve", void 0);
    _defineProperty(this, "reject", void 0);
    _defineProperty(this, "promise", void 0);
    const {
      resolve,
      reject,
      promise
    } = RSVP.defer(`ember-file-upload: ${options.label}`);
    this.resolve = resolve;
    this.reject = reject;
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    this.promise = promise;
    this.request = new XMLHttpRequest();
    this.request.withCredentials = options.withCredentials ?? false;
    let aborted;
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    promise.cancel = () => {
      if (aborted == null) {
        aborted = RSVP.defer(`ember-file-upload: Abort ${options.label}`);
        this.request.abort();
      }
      return aborted.promise;
    };
    promise.then = function (...args) {
      const newPromise = RSVP.Promise.prototype.then.apply(this, args);
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      newPromise.cancel = promise.cancel;
      newPromise.then = promise.then;
      return newPromise;
    };
    this.request.onabort = bind(this, function () {
      this.onabort?.();
      aborted.resolve();
    });
    this.request.onloadstart = this.request.onprogress = this.request.onloadend = bind(this, function (evt) {
      this.onprogress?.(evt);
    });
    if (this.request.upload) {
      this.request.upload.onprogress = this.request.onprogress;
    }
    this.request.onload = bind(this, function () {
      const response = parseResponse(this.request);
      if (Math.floor(response.status / 200) === 1) {
        resolve(response);
      } else {
        reject(response);
      }
    });
    this.request.onerror = bind(this, function () {
      reject(parseResponse(this.request));
    });
    Object.defineProperty(this, 'timeout', {
      get() {
        return this.request.timeout;
      },
      set(timeout) {
        this.request.timeout = timeout;
      },
      enumerable: true,
      configurable: false
    });
    this.request.ontimeout = bind(this, function () {
      this.ontimeout?.();
      reject(parseResponse(this.request));
    });
  }
  send(body) {
    this.request.send(body);
    return this.promise;
  }
  open(method, url, _async, usename, password) {
    this.request.open(method, url, true, usename, password);
  }
  setRequestHeader(name, value) {
    this.request.setRequestHeader(name, value);
  }
}

/**
  Provides a promise-aware interface for reading files.

  ```js
  import { UploadFile, UploadFileReader } from 'ember-file-upload';

  let reader = new UploadFileReader();
  let file = File.fromDataURL('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAAXNSR0IArs4c6QAAACNJREFUCB1jYICC6dOn/4exwTRMAEYzwBnoOmASMBpuDLIAAIVVFiE0cg0oAAAAAElFTkSuQmCC');

  reader.readAsDataURL(file.blob).then((url) => {
    return url;
  }, function (err) {
    console.error(err);
  });
  ```

  Promises can be aborted, which will cancel the file upload:

  ```js
  let promise = reader.readAsDataURL(file.blob);
  promise.then((url) => {
    return url;
  }, (err) => {
    console.error(err);
  });

  promise.abort().then(() => {
    console.error('cancelled reading file');
  });
  ```

  @class UploadFileReader
  @constructor
  @param [options] An object with a label to use to mark the promise.
 */
class UploadFileReader {
  constructor(options = {
    label: ''
  }) {
    _defineProperty(this, "label", void 0);
    _defineProperty(this, "reader", void 0);
    this.label = options.label;
    this.reader = new FileReader();
  }

  /**
    Reads the file and returns a promise that will
    return the blob as ArrayBuffer.
     @method readAsArrayBuffer
    @return {Promise} A promise that will return the file as an ArrayBuffer
   */
  readAsArrayBuffer(blob) {
    this.reader.readAsArrayBuffer(blob);
    return this.cancellablePromise;
  }

  /**
    Reads the file and returns a promise that will
    return the blob as data URL.
     This is useful for reading images to display
    as a preview in the browser.
     @method readAsDataURL
    @return {Promise} A promise that will return the file as a data URL
   */
  readAsDataURL(blob) {
    this.reader.readAsDataURL(blob);
    return this.cancellablePromise;
  }

  /**
    Reads the file and returns a promise that will
    return the blob as binary string.
     This is useful for reading images or files that
    are not plain text.
     @method readAsBinaryString
    @return {Promise} A promise that will return the file as a binary string
   */
  readAsBinaryString(blob) {
    this.reader.readAsBinaryString(blob);
    return this.cancellablePromise;
  }

  /**
    Reads the file and returns a promise that will
    return the blob as text.
     This is useful for reading plain text files.
     @method readAsText
    @return {Promise} A promise that will return the file as text
   */
  readAsText(blob) {
    this.reader.readAsText(blob);
    return this.cancellablePromise;
  }
  get cancellablePromise() {
    const {
      promise,
      resolve,
      reject
    } = RSVP.defer(`ember-file-upload: ${this.label}`);
    const cancellable = promise.then(() => {
      return this.reader.result;
    }, () => {
      return RSVP.reject(this.reader.error);
    }, `ember-file-upload: Unpack ${this.label}`);
    let abort;

    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    cancellable.cancel = () => {
      if (abort == null) {
        abort = RSVP.defer(`ember-file-upload: Abort ${this.label}`);
        this.reader.abort();
      }
      return abort.promise;
    };
    this.reader.onload = resolve;
    this.reader.onerror = reject;
    this.reader.onabort = () => {
      abort?.resolve();
    };
    return cancellable;
  }
}

export { HTTPRequest as H, UploadFileReader as U, _defineProperty as _ };
//# sourceMappingURL=upload-file-reader-a231da11.js.map
